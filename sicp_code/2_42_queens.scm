; Supporting functions
(define (filter predicate sequence)
    (cond ((null? sequence) ())
            ((predicate (car sequence))
                (cons (car sequence)
                        (filter predicate (cdr sequence))))
            (else (filter predicate (cdr sequence)))))

(define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
    (if (> low high)
        ()
        (cons low (enumerate-interval (+ low 1) high))))

(define (flatmap proc seq)
    (accumulate append () (map proc seq)))

; n-queens, offer a list of pairs:(row, col)
(define (queens board-size)
    (define empty-board '()) 
    (define (adjoin-position row col rest-of-queens)
        (cons (cons row col) rest-of-queens))
    
    (define (row position) (car position))
    (define (col position) (cdr position))
    (define (diagonal? queen1 queen2)
        (= (abs (- (row queen1) (row queen2)))
            (abs (- (col queen1) (col queen2)))))
    (define (intersect? queen1 queen2)
        (or (= (row queen1) (row queen2))
            (diagonal? queen1 queen2)))
    
    (define (safe? positions)
        (define (safe-position? queen rest-of-queens)
            (cond ((null? rest-of-queens) #t)
                    ((intersect? queen (car rest-of-queens)) #f)
                    (else (safe-position? queen (cdr rest-of-queens)))))
        (safe-position? (car positions) (cdr positions)))
    
    (define (queen-cols k)
        (if (= k 0)
            (list empty-board)
            (filter (lambda (positions) (safe? positions))
                    (flatmap (lambda (rest-of-queens)
                                    (map (lambda (new-row)
                                            (adjoin-position new-row k rest-of-queens))
                                        (enumerate-interval 1 board-size)))
                                (queen-cols (- k 1))))))
    (queen-cols board-size))